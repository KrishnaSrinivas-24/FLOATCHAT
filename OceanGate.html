<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ocean Gate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Leaflet CSS (latest) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <!-- Plotly (latest) -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root {
      --bg: #1b130d;
      --panel: #23170f;
      --text: #f1e7dd;
      --muted: #c2b8ae;
      --accent: #c38452;
      --accent-2: #d4a373;
      --danger: #f87171;
      --success: #34d399;
      --border: #3a2a1f;
      --card: #1a120b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(180deg, #140e0a, var(--bg) 25%);
      color: var(--text);
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: rgba(27, 19, 13, 0.6);
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .title {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    .pill {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #0b1220;
      color: var(--muted);
    }
    .row {
      display: grid;
      grid-template-columns: 320px 1fr 480px;
      gap: 12px;
      padding: 12px;
    }
    @media (max-width: 1100px) {
      .row {
        grid-template-columns: 1fr;
      }
      .right, .left, .center {
        height: auto;
      }
      #map { min-height: 380px; }
    }
    .panel {
      background: rgba(27, 19, 13, 0.7);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }
    .left, .right, .center {
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 86px);
    }
    .section-title {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      font-size: 14px;
      color: var(--muted);
      background: rgba(42, 30, 22, 0.6);
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 12px;
    }
    label {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
      display: block;
    }
    input, select, button, textarea {
      width: 100%;
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 14px;
      outline: none;
    }
    input:focus, select:focus, textarea:focus, button:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(195, 132, 82, 0.25);
    }
    .btn-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .btn {
      cursor: pointer;
      background: linear-gradient(180deg, #3a271a, #1a120b);
      transition: transform 0.05s ease-in, background 0.2s;
    }
    .btn:hover { background: linear-gradient(180deg, #4a3423, #1a120b); }
    .btn:active { transform: translateY(1px); }
    .btn-primary {
      background: linear-gradient(180deg, #b77d4f, #8f6037);
      border: none;
    }
    .btn-primary:hover {
      background: linear-gradient(180deg, #c5895c, #9a6a40);
    }
    /* Dynamic "jelly + jump" hover for Send button */
    #chatSendBtn {
      position: relative;
      overflow: visible;
      transform-origin: center;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.3s ease;
      box-shadow: 0 0 0 rgba(0,0,0,0);
      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(183,125,79,0.9), rgba(88, 52, 21, 0.9));
      backdrop-filter: blur(6px) saturate(140%);
      -webkit-backdrop-filter: blur(6px) saturate(140%);
      --mx: 50%;
      --my: 50%;
      /* Enhanced animations */
      animation: gentle-pulse 3s ease-in-out infinite, subtle-float 4s ease-in-out infinite;
    }
    /* Soft contact shadow below the button */
    #chatSendBtn::after {
      content: '';
      position: absolute;
      left: 10%;
      right: 10%;
      bottom: -8px;
      height: 12px;
      pointer-events: none;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.35), rgba(0,0,0,0) 70%);
      opacity: 0;
      transform: translateY(0) scale(0.7);
      filter: blur(2px);
      transition: opacity 0.25s ease, transform 0.25s ease;
    }
    /* Liquid glass inner highlight layer that follows the cursor */
    #chatSendBtn::before {
      content: '';
      position: absolute;
      inset: -1px;
      border-radius: inherit;
      background:
        radial-gradient(120px 80px at var(--mx) calc(var(--my)), rgba(255,255,255,0.26), rgba(255,255,255,0) 60%),
        radial-gradient(220px 160px at calc(100% - var(--mx)) calc(100% - var(--my)), rgba(255,255,255,0.14), rgba(255,255,255,0) 70%),
        conic-gradient(from 0deg at var(--mx) var(--my), rgba(255,255,255,0.10), rgba(255,255,255,0) 25%, rgba(0,0,0,0.12) 55%, rgba(255,255,255,0.08) 80%, rgba(255,255,255,0.10));
      mix-blend-mode: screen;
      filter: blur(8px) saturate(120%);
      opacity: 0.65;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }
    /* Top glossy streak */
    #chatSendBtn .gloss { display: none; }
    #chatSendBtn::marker { content: none; }
    #chatSendBtn > ._gloss { display: none; }
    #chatSendBtn::selection { background: transparent; }
    #chatSendBtn ._gloss { display: none; }
    #chatSendBtn ._glassGloss { display: none; }
    #chatSendBtn span.glossy { position: relative; }
    #chatSendBtn span.glossy::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(to bottom, rgba(255,255,255,0.35), rgba(255,255,255,0.15) 30%, rgba(255,255,255,0) 70%);
      mask: radial-gradient(120% 80% at 50% 0%, #000 55%, transparent 60%);
      opacity: 0.65;
      pointer-events: none;
    }
    #chatSendBtn:hover {
      animation: jelly 600ms ease both, jump 400ms ease-out both, enhanced-glow 0.3s ease-out both;
      box-shadow: 0 15px 25px rgba(0,0,0,0.4), 0 8px 15px rgba(195,132,82,0.5), 0 0 20px rgba(195,132,82,0.3);
      transform: scale(1.05) translateY(-2px);
    }
    #chatSendBtn:hover::before { animation: liquid-rotate 6s linear infinite; opacity: 0.8; }
    #chatSendBtn:hover::after {
      opacity: 0.6;
      transform: translateY(6px) scale(1.1);
    }
    /* Loading state */
    #chatSendBtn.loading {
      animation: loading-pulse 1s ease-in-out infinite, subtle-float 4s ease-in-out infinite;
      pointer-events: none;
      opacity: 0.8;
    }
    #chatSendBtn.loading::before {
      animation: loading-spin 1s linear infinite;
      opacity: 0.9;
    }
    /* Click ripple effect */
    #chatSendBtn:active {
      animation: click-ripple 0.4s ease-out both;
    }
    @keyframes jelly {
      0%   { transform: scale(1,1); }
      25%  { transform: scale(1.08, 0.92); }
      45%  { transform: scale(0.95, 1.05); }
      65%  { transform: scale(1.03, 0.97); }
      100% { transform: scale(1,1); }
    }
    @keyframes jump {
      0%   { transform: translateY(0); }
      50%  { transform: translateY(-8px); }
      100% { transform: translateY(-2px); }
    }
    @keyframes liquid-rotate { to { transform: rotate(360deg); } }
    @keyframes gentle-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    @keyframes subtle-float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-1px); }
    }
    @keyframes enhanced-glow {
      0% { box-shadow: 0 0 0 rgba(195,132,82,0); }
      100% { box-shadow: 0 15px 25px rgba(0,0,0,0.4), 0 8px 15px rgba(195,132,82,0.5), 0 0 20px rgba(195,132,82,0.3); }
    }
    @keyframes loading-pulse {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.05); }
    }
    @keyframes loading-spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    @keyframes click-ripple {
      0% { transform: scale(1); }
      50% { transform: scale(0.95); }
      100% { transform: scale(1); }
    }
    @media (prefers-reduced-motion: reduce) {
      #chatSendBtn, #chatSendBtn::after { transition: none !important; animation: none !important; }
      #chatSendBtn:hover { transform: none !important; box-shadow: none !important; }
      #chatSendBtn::after { display: none; }
    }
    .btn-danger {
      background: linear-gradient(180deg, #ef4444, #dc2626);
      border: none;
    }
    .status-area {
      margin-top: auto;
      padding: 12px;
      border-top: 1px solid var(--border);
      background: rgba(42, 30, 22, 0.5);
    }
    .status-text {
      width: 100%;
      min-height: 80px;
      resize: vertical;
      color: var(--muted);
    }
    #map {
      width: 100%;
      height: 100%;
      min-height: 520px;
    }
    .charts {
      display: grid;
      grid-template-rows: 1fr 1fr;
      gap: 10px;
      padding: 12px;
      height: 60%;
      min-height: 480px;
    }
    .chart-card {
      background: rgba(2, 6, 23, 0.3);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      padding: 8px;
    }
    .chat {
      display: flex;
      flex-direction: column;
      border-top: 1px solid var(--border);
      height: 40%;
      min-height: 240px;
      background: rgba(17, 24, 39, 0.5);
    }
    .chat-log {
      flex: 1;
      overflow: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .chat-msg {
      max-width: 90%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--card);
      line-height: 1.3;
      white-space: pre-wrap;
    }
    .chat-msg.user { align-self: flex-end; background: #2b1c12; border-color: #3a2a1f; }
    .chat-msg.bot { align-self: flex-start; }
    .chat-input {
      display: grid;
      grid-template-columns: 1fr 120px;
      gap: 8px;
      padding: 10px;
      border-top: 1px solid var(--border);
      background: rgba(27, 19, 13, 0.6);
    }
    .legend {
      position: absolute;
      z-index: 400;
      bottom: 12px;
      left: 12px;
      background: rgba(27, 19, 13, 0.8);
      color: var(--muted);
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 12px;
    }
    .header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .small {
      font-size: 12px;
      color: var(--muted);
    }
    .highlight-ring {
      pointer-events: none;
      filter: drop-shadow(0 0 6px rgba(195, 132, 82, 0.9));
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <span>Ocean Gate</span>
      <span class="pill" id="ragStatus" aria-live="polite">RAG: On</span>
    </div>
    <div class="header-actions">
      <button class="btn" id="toggleRagBtn" aria-label="Toggle RAG status">Toggle RAG</button>
      <button class="btn btn-primary" id="refreshBtn" aria-label="Refresh data">Refresh</button>
    </div>
  </header>

  <div class="row">
    <!-- Left Controls -->
    <aside class="panel left" aria-label="Controls panel">
      <div class="section-title">Filters & Actions</div>
      <div class="controls">
        <div>
          <label for="dateStart">Date start</label>
          <input type="date" id="dateStart" aria-label="Date start" />
        </div>
        <div>
          <label for="dateEnd">Date end</label>
          <input type="date" id="dateEnd" aria-label="Date end" />
        </div>
        <div>
          <label for="varSelect">Variable</label>
          <select id="varSelect" aria-label="Variable select">
            <option value="temp">Temperature (temp)</option>
            <option value="psal">Salinity (psal)</option>
            <option value="oxygen">Oxy (oxygen)</option>
          </select>
        </div>
        <div class="btn-row">
          <div>
            <label for="latMin">latMin</label>
            <input type="number" step="0.1" id="latMin" aria-label="Latitude minimum" placeholder="-90" />
          </div>
          <div>
            <label for="lonMin">lonMin</label>
            <input type="number" step="0.1" id="lonMin" aria-label="Longitude minimum" placeholder="-180" />
          </div>
        </div>
        <div class="btn-row">
          <div>
            <label for="latMax">latMax</label>
            <input type="number" step="0.1" id="latMax" aria-label="Latitude maximum" placeholder="90" />
          </div>
          <div>
            <label for="lonMax">lonMax</label>
            <input type="number" step="0.1" id="lonMax" aria-label="Longitude maximum" placeholder="180" />
          </div>
        </div>
        <div>
          <label for="floatId">Float ID (optional)</label>
          <input type="text" id="floatId" aria-label="Float ID filter" placeholder="e.g., 6901234" />
        </div>
        <div class="btn-row">
          <button class="btn btn-primary" id="applyBtn" aria-label="Apply filters">Apply</button>
          <button class="btn" id="clearBtn" aria-label="Clear filters">Clear</button>
        </div>
        <div class="btn-row">
          <button class="btn" id="nearestBtn" aria-label="Find nearest floats">Find nearest to center</button>
          <button class="btn" id="exportBtn" aria-label="Export CSV">Export CSV</button>
        </div>
      </div>
      <div class="status-area">
        <div class="small">Status</div>
        <textarea id="statusBox" class="status-text" aria-live="polite" readonly>Ready.</textarea>
      </div>
    </aside>

    <!-- Center Map -->
    <main class="panel center" aria-label="Map">
      <div class="section-title">Map</div>
      <div style="position: relative; flex: 1;">
        <div id="map" role="region" aria-label="Float map"></div>
        <div class="legend">
          <div><strong>Legend</strong></div>
          <div>• Blue marker: Float</div>
          <div>— Coffee line: Trajectory</div>
          <div>◯ Glow: Highlighted by chat</div>
        </div>
      </div>
    </main>

    <!-- Right Charts + Chat -->
    <aside class="panel right" aria-label="Charts and chat">
      <div class="section-title">Profiles & Time Series</div>
      <div class="charts">
        <div class="chart-card" aria-label="Profile chart container">
          <div id="profileChart" style="width:100%;height:100%;"></div>
        </div>
        <div class="chart-card" aria-label="Time series chart container">
          <div id="timeChart" style="width:100%;height:100%;"></div>
        </div>
      </div>
      <div class="chat" aria-label="Chat">
        <div class="chat-log" id="chatLog" aria-live="polite"></div>
        <div class="chat-input">
          <input id="chatInput" type="text" placeholder="Ask about floats, e.g., 'show floats in bbox'…" aria-label="Chat input" />
          <button id="chatSendBtn" class="btn btn-primary" aria-label="Send chat message"><span class="glossy">Send</span></button>
        </div>
      </div>
    </aside>
  </div>

  <!-- Leaflet JS (latest) -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // ---------------------------
    // Mock API Layer (replaceable)
    // ---------------------------
    // TODO: Replace mockFetch with real fetch to your backend.
    // Exact lines to edit for integration:
    // - Replace calls to mockFetch() inside: fetchFloats(), fetchProfile(), postChatQuery(), fetchExportCSV().
    // - Update the endpoint URLs accordingly (e.g., '/api/floats', '/api/float/:id/profile?var=', '/api/query', '/api/export?...').

    // Inline mock data EXACTLY as required:
    const MOCK_FLOATS_RESPONSE = [
      {"id":"6901234","lat":8.5,"lon":72.2,"last":"2023-03-12","trajectory":[[8.1,71.9],[8.3,72.0],[8.5,72.2]]},
      {"id":"5904321","lat":-2.1,"lon":68.3,"last":"2023-03-20","trajectory":[[-2.5,68.0],[-2.3,68.1],[-2.1,68.3]]}
    ];
    const MOCK_PROFILE_6901234_TEMP = {"id":"6901234","var":"temp","profile":[{"pres":0,"value":29,"time":"2023-03-12T10:00Z"},{"pres":10,"value":28,"time":"2023-03-12T10:02Z"},{"pres":50,"value":24,"time":"2023-03-12T10:07Z"}]};
    const MOCK_CHAT_RESPONSE = {"replyText":"Found 2 floats within bbox. Showing 2 on map.","actions":[{"type":"show_floats","ids":["6901234","5904321"]}]};

    // Simulated fetch function. Swap with real fetch(...) below.
    async function mockFetch(url, options = {}) {
      await new Promise(res => setTimeout(res, 450)); // simulate latency

      // GET /api/floats?...
      if (url.startsWith('/api/floats')) {
        return { ok: true, json: async () => MOCK_FLOATS_RESPONSE };
      }

      // GET /api/float/:id/profile?var=
      if (url.startsWith('/api/float/')) {
        // only the exact provided mock guaranteed
        const match = url.match(/^\/api\/float\/([^/]+)\/profile\?var=([^&]+)/);
        if (match) {
          const id = match[1];
          const variable = match[2];
          if (id === '6901234' && variable === 'temp') {
            return { ok: true, json: async () => MOCK_PROFILE_6901234_TEMP };
          }
          // Minimal synthetic profile for other cases
          const depths = [0, 10, 20, 50, 100, 200, 500, 1000];
          const gen = depths.map((p, i) => ({
            pres: p,
            value: variable === 'psal' ? 35 - i * 0.1 : variable === 'oxygen' ? 250 - i * 5 : 28 - i * 0.8,
            time: new Date(Date.now() - i * 60000).toISOString()
          }));
          return { ok: true, json: async () => ({ id, var: variable, profile: gen }) };
        }
      }

      // POST /api/query
      if (url === '/api/query' && options.method === 'POST') {
        return { ok: true, json: async () => MOCK_CHAT_RESPONSE };
      }

      // GET /api/export?format=csv&...
      if (url.startsWith('/api/export')) {
        // Return CSV text as body
        const csv = 'id,lat,lon,last\n' +
          MOCK_FLOATS_RESPONSE.map(f => `${f.id},${f.lat},${f.lon},${f.last}`).join('\n');
        return { ok: true, text: async () => csv };
      }

      return { ok: false, status: 404, json: async () => ({ error: 'Not found' }) };
    }

    // ---------------------------
    // API wrappers (swap internals)
    // ---------------------------
    async function fetchFloats(filters) {
      const params = new URLSearchParams(filters || {});
      const url = '/api/floats' + (params.toString() ? `?${params.toString()}` : '');
      // TODO: Replace mockFetch with: return fetch(url)
      const res = await mockFetch(url);
      if (!res.ok) throw new Error('Failed to fetch floats');
      return res.json();
    }

    async function fetchProfile(floatId, variable) {
      const url = `/api/float/${encodeURIComponent(floatId)}/profile?var=${encodeURIComponent(variable)}`;
      // TODO: Replace mockFetch with: return fetch(url)
      const res = await mockFetch(url);
      if (!res.ok) throw new Error('Failed to fetch profile');
      return res.json();
    }

    async function postChatQuery(text) {
      // TODO: Replace mockFetch with: return fetch('/api/query', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ text }) })
      const res = await mockFetch('/api/query', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text }) });
      if (!res.ok) throw new Error('Chat query failed');
      return res.json();
    }

    async function fetchExportCSV(filters) {
      const params = new URLSearchParams({ format: 'csv', ...(filters || {}) });
      const url = `/api/export?${params.toString()}`;
      // TODO: Replace mockFetch with: return fetch(url)
      const res = await mockFetch(url);
      if (!res.ok) throw new Error('Export failed');
      return res.text();
    }

    // ---------------------------
    // App State
    // ---------------------------
    let map, floatsLayer, trajectoryLayer, highlightLayer;
    let idToMarker = new Map();
    let highlightedIds = new Set();
    let ragOn = true;

    // ---------------------------
    // Utilities
    // ---------------------------
    function setStatus(message, level = 'info') {
      const box = document.getElementById('statusBox');
      const prefix = level === 'error' ? '⛔ ' : level === 'success' ? '✅ ' : level === 'warn' ? '⚠️ ' : 'ℹ️ ';
      box.value = `${prefix}${message}\n` + box.value;
    }

    function getFiltersFromInputs() {
      return {
        start: document.getElementById('dateStart').value || '',
        end: document.getElementById('dateEnd').value || '',
        var: document.getElementById('varSelect').value || 'temp',
        latmin: document.getElementById('latMin').value || '',
        lonmin: document.getElementById('lonMin').value || '',
        latmax: document.getElementById('latMax').value || '',
        lonmax: document.getElementById('lonMax').value || '',
        id: document.getElementById('floatId').value || ''
      };
    }

    function clearInputs() {
      ['dateStart','dateEnd','latMin','lonMin','latMax','lonMax','floatId'].forEach(id => document.getElementById(id).value = '');
      document.getElementById('varSelect').value = 'temp';
    }

    function computeDistanceKm(a, b) {
      const R = 6371;
      const dLat = (b.lat - a.lat) * Math.PI / 180;
      const dLon = (b.lon - a.lon) * Math.PI / 180;
      const lat1 = a.lat * Math.PI / 180;
      const lat2 = b.lat * Math.PI / 180;
      const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(h));
    }

    // ---------------------------
    // Map Initialization
    // ---------------------------
    function initMap() {
      map = L.map('map').setView([8, 70], 5);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap',
        maxZoom: 18
      }).addTo(map);

      floatsLayer = L.layerGroup().addTo(map);
      trajectoryLayer = L.layerGroup().addTo(map);
      highlightLayer = L.layerGroup().addTo(map);
    }

    function clearMapLayers() {
      floatsLayer.clearLayers();
      trajectoryLayer.clearLayers();
      idToMarker.clear();
    }

    function drawTrajectory(latlngs) {
      trajectoryLayer.clearLayers();
      if (latlngs && latlngs.length > 1) {
        L.polyline(latlngs, { color: '#d4a373', weight: 3, opacity: 0.9 }).addTo(trajectoryLayer);
      }
    }

    function applyHighlights() {
      highlightLayer.clearLayers();
      highlightedIds.forEach(id => {
        const marker = idToMarker.get(id);
        if (marker) {
          const latlng = marker.getLatLng();
          L.circleMarker(latlng, {
            radius: 14,
            color: '#c38452',
            weight: 2,
            opacity: 0.9,
            fillOpacity: 0.05
          }).addTo(highlightLayer).getElement()?.classList?.add('highlight-ring');
        }
      });
    }

    function createMarker(floatObj) {
      const marker = L.marker([floatObj.lat, floatObj.lon], { title: `Float ${floatObj.id}` });
      const popupHtml = `
        <div>
          <div><strong>Float:</strong> ${floatObj.id}</div>
          <div><strong>Last:</strong> ${floatObj.last}</div>
          <div style="margin-top:6px; display:flex; gap:6px;">
            <button class="leaflet-popup-close-btn-custom" style="cursor:pointer;padding:4px 8px;border-radius:6px;border:1px solid var(--border);background:var(--card);color:var(--text);" onclick="viewProfile('${floatObj.id}')">View profile</button>
          </div>
        </div>
      `;
      marker.bindPopup(popupHtml);

      marker.on('click', () => {
        // draw trajectory on marker click
        if (Array.isArray(floatObj.trajectory)) {
          const latlngs = floatObj.trajectory.map(([lat, lon]) => [lat, lon]);
          drawTrajectory(latlngs);
        }
      });

      return marker;
    }

    // ---------------------------
    // Charts
    // ---------------------------
    function initCharts() {
      Plotly.newPlot('profileChart', [{
        x: [],
        y: [],
        mode: 'lines+markers',
        name: 'Profile'
      }], {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#f1e7dd' },
        xaxis: { title: 'Value', zeroline: false, gridcolor: '#3a2a1f' },
        yaxis: { title: 'Pressure (dbar)', autorange: 'reversed', gridcolor: '#3a2a1f' },
        margin: { l: 50, r: 10, t: 10, b: 40 },
        hovermode: 'closest',
        legend: { orientation: 'h', y: -0.2 }
      }, { displayModeBar: false });

      Plotly.newPlot('timeChart', [{
        x: [],
        y: [],
        mode: 'lines+markers',
        name: 'Time series'
      }], {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#f1e7dd' },
        xaxis: { title: 'Time', gridcolor: '#3a2a1f', type: 'date' },
        yaxis: { title: 'Value', gridcolor: '#3a2a1f' },
        margin: { l: 50, r: 10, t: 10, b: 40 },
        hovermode: 'x unified',
        legend: { orientation: 'h', y: -0.2 }
      }, { displayModeBar: false });
    }

    function plotProfile(profileJson) {
      const varLabel = profileJson.var === 'temp' ? 'Temperature (°C)'
                      : profileJson.var === 'psal' ? 'Salinity (PSU)'
                      : 'Oxygen (µmol/kg)';
      const x = profileJson.profile.map(p => p.value);
      const y = profileJson.profile.map(p => p.pres);
      const hoverText = profileJson.profile.map(p => `Pres: ${p.pres} dbar<br>Val: ${p.value}<br>Time: ${p.time}`);

      const trace = {
        x, y, mode: 'lines+markers', name: varLabel,
        hoverinfo: 'text', text: hoverText, line: { color: '#c38452' }, marker: { color: '#c38452' }
      };

      Plotly.react('profileChart', [trace], {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#f1e7dd' },
        xaxis: { title: varLabel, gridcolor: '#3a2a1f' },
        yaxis: { title: 'Pressure (dbar)', autorange: 'reversed', gridcolor: '#3a2a1f' },
        margin: { l: 60, r: 10, t: 10, b: 50 },
        hovermode: 'closest',
        legend: { orientation: 'h', y: -0.2 }
      }, { displayModeBar: false });

      // Simple synthesized time series using profile points for demo
      const tx = profileJson.profile.map(p => p.time);
      const ty = x;
      Plotly.react('timeChart', [{
        x: tx, y: ty, mode: 'lines+markers', name: varLabel, line: { color: '#d4a373' }, marker: { color: '#d4a373' }
      }], {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#f1e7dd' },
        xaxis: { title: 'Time', type: 'date', gridcolor: '#3a2a1f' },
        yaxis: { title: varLabel, gridcolor: '#3a2a1f' },
        margin: { l: 60, r: 10, t: 10, b: 50 },
        hovermode: 'x unified',
        legend: { orientation: 'h', y: -0.2 }
      }, { displayModeBar: false });
    }

    // ---------------------------
    // Core behavior functions (exposed on window)
    // ---------------------------
    async function refreshMap(filters = {}) {
      try {
        setStatus('Loading floats…');
        clearMapLayers();

        const data = await fetchFloats(filters);
        const bounds = [];
        data.forEach(f => {
          const m = createMarker(f);
          m.addTo(floatsLayer);
          idToMarker.set(f.id, m);
          bounds.push([f.lat, f.lon]);
        });

        if (bounds.length) {
          map.fitBounds(bounds, { padding: [30, 30] });
        }

        applyHighlights();
        setStatus(`Loaded ${data.length} floats.`, 'success');
        return data;
      } catch (err) {
        console.error(err);
        setStatus(`Error loading floats: ${err.message}`, 'error');
      }
    }

    async function viewProfile(floatId) {
      try {
        const variable = document.getElementById('varSelect').value || 'temp';
        setStatus(`Fetching profile for ${floatId} (${variable})…`);
        const prof = await fetchProfile(floatId, variable);
        plotProfile(prof);

        // center map on float and show popup, draw trajectory if available
        const marker = idToMarker.get(floatId);
        if (marker) {
          map.setView(marker.getLatLng(), Math.max(map.getZoom(), 6));
          marker.openPopup();
        }
        // draw known trajectory if available from current floats data
        const floats = await fetchFloats(getFiltersFromInputs()).catch(() => []);
        const sel = (floats || []).find(f => f.id === floatId);
        if (sel && Array.isArray(sel.trajectory)) {
          const latlngs = sel.trajectory.map(([lat, lon]) => [lat, lon]);
          drawTrajectory(latlngs);
        }

        setStatus(`Profile plotted for ${floatId}.`, 'success');
      } catch (err) {
        console.error(err);
        setStatus(`Error fetching profile: ${err.message}`, 'error');
      }
    }

    async function applyFilters() {
      const filters = getFiltersFromInputs();
      await refreshMap(filters);
    }

    async function sendChatQuery(text) {
      if (!text || !text.trim()) return;
      
      const sendBtn = document.getElementById('chatSendBtn');
      sendBtn.classList.add('loading');
      sendBtn.disabled = true;
      
      addChatMessage('user', text.trim());
      showTyping(true);

      try {
        const res = await postChatQuery(text.trim());
        showTyping(false);
        addChatMessage('bot', res.replyText || 'No reply.');
        await handleChatActions(res.actions || []);
      } catch (err) {
        showTyping(false);
        addChatMessage('bot', `Error: ${err.message}`);
      } finally {
        // Remove loading state with a slight delay for better UX
        setTimeout(() => {
          sendBtn.classList.remove('loading');
          sendBtn.disabled = false;
        }, 500);
      }
    }

    // ---------------------------
    // Chat helpers
    // ---------------------------
    function addChatMessage(role, content) {
      const log = document.getElementById('chatLog');
      const div = document.createElement('div');
      div.className = `chat-msg ${role}`;
      div.textContent = content;
      log.appendChild(div);
      log.scrollTop = log.scrollHeight;
    }

    let typingEl = null;
    function showTyping(on) {
      const log = document.getElementById('chatLog');
      if (on) {
        typingEl = document.createElement('div');
        typingEl.className = 'chat-msg bot';
        typingEl.textContent = 'Assistant is typing…';
        log.appendChild(typingEl);
      } else if (typingEl) {
        typingEl.remove();
        typingEl = null;
      }
      log.scrollTop = log.scrollHeight;
    }

    async function handleChatActions(actions) {
      for (const a of actions) {
        if (a.type === 'show_floats' && Array.isArray(a.ids)) {
          highlightedIds = new Set(a.ids);
          applyHighlights();
          // Fit bounds to highlighted
          const pts = a.ids.map(id => idToMarker.get(id)).filter(Boolean).map(m => m.getLatLng());
          if (pts.length) {
            const bounds = L.latLngBounds(pts);
            map.fitBounds(bounds.pad(0.2));
          }
          setStatus(`Highlighted ${a.ids.length} float(s) from chat.`, 'success');
        }
      }
    }

    // ---------------------------
    // Nearest float to map center
    // ---------------------------
    async function findNearestToCenter() {
      const center = map.getCenter();
      const floats = await fetchFloats(getFiltersFromInputs());
      if (!floats.length) {
        setStatus('No floats available.', 'warn');
        return;
      }
      let best = null;
      let bestDist = Infinity;
      floats.forEach(f => {
        const d = computeDistanceKm({ lat: center.lat, lon: center.lng }, { lat: f.lat, lon: f.lon });
        if (d < bestDist) {
          best = f;
          bestDist = d;
        }
      });
      if (best) {
        const marker = idToMarker.get(best.id);
        if (marker) {
          map.setView(marker.getLatLng(), Math.max(map.getZoom(), 6));
          marker.openPopup();
          setStatus(`Nearest float: ${best.id} (${bestDist.toFixed(1)} km)`, 'success');
        } else {
          setStatus('Nearest float found but not on current map.', 'warn');
        }
      }
    }

    // ---------------------------
    // Export CSV
    // ---------------------------
    async function exportCSV() {
      try {
        setStatus('Preparing CSV download…');
        const csvText = await fetchExportCSV(getFiltersFromInputs());
        const blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'argo_floats.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        setStatus('CSV download started.', 'success');
      } catch (err) {
        console.error(err);
        setStatus(`Export failed: ${err.message}`, 'error');
      }
    }

    // ---------------------------
    // Event wiring
    // ---------------------------
    function wireEvents() {
      document.getElementById('applyBtn').addEventListener('click', applyFilters);
      document.getElementById('clearBtn').addEventListener('click', () => { clearInputs(); applyFilters(); });
      document.getElementById('nearestBtn').addEventListener('click', findNearestToCenter);
      document.getElementById('exportBtn').addEventListener('click', exportCSV);
      document.getElementById('refreshBtn').addEventListener('click', () => refreshMap(getFiltersFromInputs()));

      const chatInput = document.getElementById('chatInput');
      document.getElementById('chatSendBtn').addEventListener('click', () => { sendChatQuery(chatInput.value); chatInput.value = ''; });
      // Cursor-following liquid glass effect
      const sendBtn = document.getElementById('chatSendBtn');
      sendBtn.addEventListener('mousemove', (e) => {
        const rect = sendBtn.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        sendBtn.style.setProperty('--mx', x + '%');
        sendBtn.style.setProperty('--my', y + '%');
      });
      sendBtn.addEventListener('mouseleave', () => {
        sendBtn.style.setProperty('--mx', '50%');
        sendBtn.style.setProperty('--my', '50%');
      });
      chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendChatQuery(chatInput.value);
          chatInput.value = '';
        }
      });

      document.getElementById('toggleRagBtn').addEventListener('click', () => {
        ragOn = !ragOn;
        document.getElementById('ragStatus').textContent = `RAG: ${ragOn ? 'On' : 'Off'}`;
      });
    }

    // ---------------------------
    // Expose for manual testing
    // ---------------------------
    window.refreshMap = refreshMap;
    window.viewProfile = viewProfile;
    window.applyFilters = applyFilters;
    window.sendChatQuery = sendChatQuery;

    // ---------------------------
    // Boot
    // ---------------------------
    window.addEventListener('DOMContentLoaded', async () => {
      initMap();
      initCharts();
      wireEvents();
      await refreshMap(); // Markers appear on load using mock floats
      setStatus('Ready. Use controls or chat to explore.');
    });
  </script>
</body>
</html>